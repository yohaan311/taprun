<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tap Dash - Hyper Casual Arcade Game</title>
    <style>
        :root {
            --color-white: rgba(255, 255, 255, 1);
            --color-black: rgba(0, 0, 0, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-gray-200: rgba(245, 245, 245, 1);
            --color-gray-300: rgba(167, 169, 169, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-background: var(--color-cream-50);
            --color-text: var(--color-slate-900);
            --color-primary: var(--color-teal-500);
            --color-primary-hover: var(--color-teal-600);
            --font-family-base: "Arial", sans-serif;
            --radius-base: 8px;
            --space-16: 16px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family-base);
            background-color: var(--color-background);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            color: var(--color-text);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #gameContainer {
            position: relative;
            max-width: 100%;
            max-height: 100vh;
        }

        #gameCanvas {
            display: block;
            border: 2px solid var(--color-gray-300);
            border-radius: var(--radius-base);
            background-color: #ecf0f1;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .info {
            text-align: center;
            margin-top: var(--space-16);
            font-size: 14px;
            color: var(--color-text);
            opacity: 0.7;
        }

        @media (max-width: 850px) {
            #gameCanvas {
                border: none;
                border-radius: 0;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div class="info">
        <p>Tap or Click to Jump â€¢ Progressive Difficulty</p>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            character: {
                size: 50,
                color: '#3498db',
                jumpPower: 15,
                gravity: 0.6,
                groundY: 450
            },
            obstacles: {
                width: 60,
                height: 40,
                color: '#e74c3c',
                initialSpeed: 5,
                maxSpeed: 10,
                spawnInterval: 1500,
                minSpawnInterval: 600
            },
            gameplay: {
                initialSpeed: 5,
                difficultyInterval: 10,
                speedIncreasePerLevel: 1.05,
                spawnFrequencyInterval: 20,
                spawnReduction: 0.95
            },
            canvas: {
                width: 800,
                height: 600,
                backgroundColor: '#ecf0f1'
            },
            ui: {
                font: 'Arial, sans-serif',
                fontSize: 24,
                scoreColor: '#2c3e50'
            }
        };

        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas sizing
        function resizeCanvas() {
            const maxWidth = Math.min(CONFIG.canvas.width, window.innerWidth - 20);
            const maxHeight = Math.min(CONFIG.canvas.height, window.innerHeight - 100);
            const scale = Math.min(maxWidth / CONFIG.canvas.width, maxHeight / CONFIG.canvas.height);
            
            canvas.width = CONFIG.canvas.width;
            canvas.height = CONFIG.canvas.height;
            canvas.style.width = (CONFIG.canvas.width * scale) + 'px';
            canvas.style.height = (CONFIG.canvas.height * scale) + 'px';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game State
        let gameState = 'start'; // 'start', 'playing', 'gameOver'
        let score = 0;
        let highScore = 0;
        let obstacleSpeed = CONFIG.gameplay.initialSpeed;
        let spawnInterval = CONFIG.obstacles.spawnInterval;
        let lastSpawnTime = 0;
        let lastDifficultyIncrease = 0;
        let lastSpawnIncrease = 0;

        // Character Object
        const character = {
            x: 150,
            y: CONFIG.character.groundY,
            size: CONFIG.character.size,
            velocityY: 0,
            isJumping: false,
            color: CONFIG.character.color,
            
            jump() {
                if (!this.isJumping) {
                    this.velocityY = -CONFIG.character.jumpPower;
                    this.isJumping = true;
                }
            },
            
            update() {
                this.velocityY += CONFIG.character.gravity;
                this.y += this.velocityY;
                
                if (this.y >= CONFIG.character.groundY) {
                    this.y = CONFIG.character.groundY;
                    this.velocityY = 0;
                    this.isJumping = false;
                }
            },
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                
                // Shadow effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(this.x + 5, this.y + 5, this.size, this.size);
                
                // Redraw character on top
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            },
            
            reset() {
                this.y = CONFIG.character.groundY;
                this.velocityY = 0;
                this.isJumping = false;
            }
        };

        // Obstacles Array
        let obstacles = [];

        class Obstacle {
            constructor() {
                this.width = CONFIG.obstacles.width;
                this.height = CONFIG.obstacles.height;
                this.x = CONFIG.canvas.width;
                this.y = CONFIG.character.groundY + CONFIG.character.size - this.height;
                this.color = CONFIG.obstacles.color;
                this.passed = false;
            }
            
            update() {
                this.x -= obstacleSpeed;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Shadow effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(this.x + 3, this.y + 3, this.width, this.height);
                
                // Redraw obstacle on top
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            
            isOffScreen() {
                return this.x + this.width < 0;
            }
            
            collidesWith(char) {
                return char.x < this.x + this.width &&
                       char.x + char.size > this.x &&
                       char.y < this.y + this.height &&
                       char.y + char.size > this.y;
            }
        }

        // Spawn Obstacles
        function spawnObstacle(currentTime) {
            if (currentTime - lastSpawnTime > spawnInterval) {
                obstacles.push(new Obstacle());
                lastSpawnTime = currentTime;
            }
        }

        // Collision Detection
        function checkCollisions() {
            for (let obstacle of obstacles) {
                if (obstacle.collidesWith(character)) {
                    gameOver();
                    return;
                }
                
                // Increase score when passing obstacle
                if (!obstacle.passed && obstacle.x + obstacle.width < character.x) {
                    obstacle.passed = true;
                    score++;
                    updateDifficulty();
                }
            }
        }

        // Update Difficulty
        function updateDifficulty() {
            // Increase speed every 10 points
            if (score > 0 && score % CONFIG.gameplay.difficultyInterval === 0 && score !== lastDifficultyIncrease) {
                obstacleSpeed = Math.min(
                    obstacleSpeed * CONFIG.gameplay.speedIncreasePerLevel,
                    CONFIG.obstacles.maxSpeed
                );
                lastDifficultyIncrease = score;
            }
            
            // Increase spawn frequency every 20 points
            if (score > 0 && score % CONFIG.gameplay.spawnFrequencyInterval === 0 && score !== lastSpawnIncrease) {
                spawnInterval = Math.max(
                    spawnInterval * CONFIG.gameplay.spawnReduction,
                    CONFIG.obstacles.minSpawnInterval
                );
                lastSpawnIncrease = score;
            }
        }

        // Draw Ground Line
        function drawGround() {
            const groundY = CONFIG.character.groundY + CONFIG.character.size;
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(CONFIG.canvas.width, groundY);
            ctx.stroke();
        }

        // Draw Score
        function drawScore() {
            ctx.fillStyle = CONFIG.ui.scoreColor;
            ctx.font = `bold ${CONFIG.ui.fontSize}px ${CONFIG.ui.font}`;
            ctx.textAlign = 'right';
            ctx.fillText(`Score: ${score}`, CONFIG.canvas.width - 20, 40);
            
            ctx.textAlign = 'left';
            ctx.fillText(`Best: ${highScore}`, 20, 40);
        }

        // Draw Start Screen
        function drawStartScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TAP DASH', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 - 80);
            
            ctx.font = '32px Arial';
            ctx.fillText('TAP TO START', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2);
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#ecf0f1';
            ctx.fillText('Tap or Click to Jump Over Obstacles', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 60);
            ctx.fillText('Survive as Long as You Can!', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 90);
        }

        // Draw Game Over Screen
        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 - 80);
            
            ctx.font = '32px Arial';
            ctx.fillText(`Score: ${score}`, CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 - 20);
            
            if (score === highScore && score > 0) {
                ctx.fillStyle = '#f39c12';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('NEW HIGH SCORE!', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 20);
            } else {
                ctx.fillStyle = '#ecf0f1';
                ctx.font = '24px Arial';
                ctx.fillText(`Best: ${highScore}`, CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 20);
            }
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '28px Arial';
            ctx.fillText('TAP TO RESTART', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 80);
        }

        // Start Game
        function startGame() {
            gameState = 'playing';
            score = 0;
            obstacles = [];
            obstacleSpeed = CONFIG.gameplay.initialSpeed;
            spawnInterval = CONFIG.obstacles.spawnInterval;
            lastSpawnTime = 0;
            lastDifficultyIncrease = 0;
            lastSpawnIncrease = 0;
            character.reset();
        }

        // Game Over
        function gameOver() {
            gameState = 'gameOver';
            if (score > highScore) {
                highScore = score;
            }
        }

        // Handle Input
        function handleInput() {
            if (gameState === 'start') {
                startGame();
            } else if (gameState === 'playing') {
                character.jump();
            } else if (gameState === 'gameOver') {
                startGame();
            }
        }

        // Event Listeners
        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        // Keyboard support (spacebar)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                handleInput();
            }
        });

        // Game Loop
        let lastTime = 0;
        function gameLoop(currentTime) {
            // Clear canvas
            ctx.fillStyle = CONFIG.canvas.backgroundColor;
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
            
            // Draw ground
            drawGround();
            
            if (gameState === 'playing') {
                // Update and draw character
                character.update();
                character.draw();
                
                // Spawn obstacles
                spawnObstacle(currentTime);
                
                // Update and draw obstacles
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    obstacles[i].update();
                    obstacles[i].draw();
                    
                    // Remove off-screen obstacles
                    if (obstacles[i].isOffScreen()) {
                        obstacles.splice(i, 1);
                    }
                }
                
                // Check collisions
                checkCollisions();
                
                // Draw score
                drawScore();
            } else if (gameState === 'start') {
                // Draw character in start position
                character.draw();
                drawScore();
                drawStartScreen();
            } else if (gameState === 'gameOver') {
                // Draw final state
                character.draw();
                for (let obstacle of obstacles) {
                    obstacle.draw();
                }
                drawGameOverScreen();
            }
            
            lastTime = currentTime;
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>